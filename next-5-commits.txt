Commit 3: feat(animation): implement FLIP morphing animation

Objective: Bring the editor to life with the seamless expanding transition.

src/components/form.ts Changes (Pseudocode for openEditor)

// Inside openEditor(entityToEdit, triggerElement) function...
// AFTER rendering the form...

// FLIP Animation Logic
const section = triggerElement.closest('section');
const editorContainer = section.querySelector('.editor-container');
const contentContainer = section.querySelector('.content-with-preview');

// 1. FIRST: Get the position of the clicked element (the start)
const startRect = triggerElement.getBoundingClientRect();

// Hide original content, show the editor in its final state to measure it
contentContainer.style.display = 'none';
editorContainer.style.display = 'block';

// 2. LAST: Get the position of the editor (the end)
const endRect = editorContainer.getBoundingClientRect();

// 3. INVERT: Calculate the difference and apply an inverse transform
//    to make the editor start exactly where the trigger element was.
const deltaX = startRect.left - endRect.left;
const deltaY = startRect.top - endRect.top;
const deltaW = startRect.width / endRect.width;
const deltaH = startRect.height / endRect.height;

editorContainer.style.transform = `
  translateX(${deltaX}px)
  translateY(${deltaY}px)
  scaleX(${deltaW})
  scaleY(${deltaH})
`;

// 4. PLAY: Force the browser to apply the transform, then remove it.
//    The CSS transition will handle the animation.
requestAnimationFrame(() => {
  editorContainer.classList.add('is-animating');
  editorContainer.style.transform = 'none'; // Animate to default state
});

// Clean up animation class after it finishes
editorContainer.addEventListener('transitionend', () => {
    editorContainer.classList.remove('is-animating');
}, { once: true });

Commit 4: refactor(form): add zod validation and persistence

Objective: Add data validation with zod and persist changes to localStorage.

New File: src/types/schemas.ts (Example)

import { z } from 'zod';

export const costSchema = z.object({
  food: z.number().min(0).optional(),
  wood: z.number().min(0).optional(),
  // ...
});

export const unitSchema = z.object({
  name: z.string().min(1, "Name cannot be empty"),
  hitpoints: z.number().min(1, "Unit must have at least 1 HP"),
  cost: costSchema,
  // ... other fields matching the Unit type
});

src/components/form.ts Changes (Pseudocode)

// Add a handleSave function
function handleSave() {
  try {
    // 1. Validate the current state
    const validatedEntity = unitSchema.parse(editingEntity);

    // 2. Find and update the entity in the main `data` object
    // This requires passing `data` into this module or having a setter function
    updateGlobalEntity(validatedEntity);

    // 3. Persist the entire civ to localStorage
    localStorage.setItem('customGreekCiv', JSON.stringify(data));

    // 4. Re-render the main UI to show changes
    renderAll();

    // 5. Close the editor with a reverse animation
    closeEditor();

  } catch (err) {
    if (err instanceof z.ZodError) {
      // Display validation errors to the user inside the form
      displayFormErrors(err.flatten().fieldErrors);
    }
  }
}
